---
title: "checkpoint1"
author: "Paulo Soares"
date: "25 de julho de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


```{r}
# Library Imports
library(tidyverse)
library(plotly)
library(resample)
```

```{r}
# database imports
programming_languages_data <- read.csv("https://raw.githubusercontent.com/nazareno/fpcc2/master/datasets/github-users-committing-filetypes.csv")

# inserting the full date to better analysis
programming_languages_data <- programming_languages_data %>% mutate(full_date = paste(month_day, the_month, the_year, sep = '-'))

# inserting the weekdays to answer the first question
programming_languages_data <- programming_languages_data %>% mutate(week_day= weekdays(as.Date(full_date,"%Y-%m-%d")))
```

```{r}
unique(programming_languages_data$file_extension)
```
Primeiro, faz-se necessária a análise das linguagens de programação disponíveis na nossa amostra. Com o *unique* podemos verificar que existem dados sobre 42 linguagens de programação, das quais iremos escolher **duas** para detalharmos um pouco mais.

```{r}
# Comentar sobre as variáveis disponíveis nos dados, como a extensão do arquivo, dia, mês e ano, além dos usuários.
```

Das linguagens disponíveis na amostra, irei escolher duas linguagens bastante populares: C++, cuja extensão é *.cpp*; e Python, cuja extensão do arquivo é *.py*.

```{r}
cpp_data <- programming_languages_data %>% filter(file_extension == "cpp")
python_data <- programming_languages_data %>% filter(file_extension == "py")
```

Agora vamos criar a nossa linha do tempo para as duas linguagens de programação. Vamos filtrar as informações sobre as linguagens de programação pelos meses.

```{r}
# Filtering for C++
cpp_data.2017 <- cpp_data %>% 
  filter(the_year == 2017) %>% 
  group_by(the_month) %>% 
  mutate(contributions_month = sum(users))
cpp_data.2016 <- cpp_data %>% 
  filter(the_year == 2016) %>% 
  group_by(the_month) %>% 
  mutate(contributions_month = sum(users))

cpp_data <- rbind(cpp_data.2016, cpp_data.2017)

# Filtering for Python
python_data.2017 <- python_data %>% 
  filter(the_year == 2017) %>% 
  group_by(the_month) %>% 
  mutate(contributions_month = sum(users))
python_data.2016 <- python_data %>% 
  filter(the_year == 2016) %>% 
  group_by(the_month) %>% 
  mutate(contributions_month = sum(users))

python_data <- rbind(python_data.2016, python_data.2017)
```

Utilizando o Plotly para gerar o nosso gráfico podemos visualizar abaixo a linha do tempo para **Python** e **C++**.cpp_data
```{r}
# C++ Plotly Data
plot_ly(data=cpp_data, x=~the_month, y=~contributions_month, color=as.factor(cpp_data$the_year), name="Popularidade por mês de C++") %>% layout(xaxis = list(title = "Mês"), yaxis = list(title = "Contribuição de usuários")) %>% 
  add_markers(hoverinfo = 'text', text=~paste('Linguagem de programação: C++', '<br>Contribuições de usuários: ', contributions_month, '<br>Mês: ', the_month, '<br>Ano: ', the_year))

# Python Plotly Data
plot_ly(data=python_data,x=~the_month, y=~contributions_month, color=as.factor(python_data$the_year), name="Popularidade por mês de Python") %>% layout(xaxis = list(title = "Mês"), yaxis = list(title = "Contribuição de usuários")) %>% 
  add_markers(hoverinfo = 'text', text=~paste('Linguagem de programação: Python', '<br>Contribuições de usuários: ', contributions_month, '<br>Mês: ', the_month, '<br>Ano: ', the_year))
```

Agora, vamos agrupar os dados pelos dias de semana e final de semana:
```{r}
library(chron)

## C++ Data
# Selecting the weekend period
cpp_data_wknd <- cpp_data %>% mutate(wknd = is.weekend(full_date))


## Python Data
# Selecting the weekend period
python_data_wknd <- python_data %>% mutate(wknd = is.weekend(full_date))
```

## Primeira pergunta: Para cada linguagem de programação há uma diferença significativa na sua popularidade durante a semana e durante o fim de semana? Essa diferença é grande?

Dado que nossos dados refletem uma **amostra**, os resultados podem não ser muito confiáveis, uma vez que não estamos trabalhando com o universo total dos dados, a população. Sabendo desse detalhe, utilizaremos uma técnica chamada *bootstrap* que melhora consideravelmente a confiabilidade dos dados nos permitindo determinar um intervalo de confiança.

```{r}
# Plotting the C++ scatter graph

cpp_data_wknd %>%
  ggplot(aes(x = wknd, y = users)) +
  geom_jitter(width = .1, color = "#488888") +
  labs(title = "Atividade de usuários C++", x = "Fim de semana", y = "Usuários") +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r}
# Plotting the Python scatter graph
python_data_wknd %>%
  ggplot(aes(x = wknd, y = users)) +
  geom_jitter(width = .1, color = "#488888") +
  labs(title = "Atividade de usuários Python", x = "Fim de semana", y = "Usuários") +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r}
# C++ Data Bootstraping

median_cpp <- bootstrap2(cpp_data_wknd$users, 
                         treatment = cpp_data_wknd$wknd,
                         median,
                         R = 15000)

median_cpp_ci <- CI.percentile(median_cpp, probs = c(.025, .975))

data.frame(median_cpp_ci) %>% 
  ggplot() + 
  geom_errorbar(aes(x = "Diferença", ymin = X2.5., ymax = X97.5.), width = .2) + 
  geom_hline(yintercept = 0, colour = "darkorange")
```

```{r}
# Python Data Bootstraping

median_python <- bootstrap2(python_data_wknd$users, 
                         treatment = python_data_wknd$wknd,
                         median,
                         R = 15000)

median_python_ci <- CI.percentile(median_python, probs = c(.025, .975))

data.frame(median_python_ci) %>% 
  ggplot() + 
  geom_errorbar(aes(x = "Diferença", ymin = X2.5., ymax = X97.5.), width = .2) + 
  geom_hline(yintercept = 0, colour = "darkorange")
```


## Segunda pergunta: Existe uma diferença significativa entre as duas linguagens na sua variação de popularidade nos finais de semana?


